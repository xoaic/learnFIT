<h3>System <u>context</u> and interactions</h3><p>The first stage in any software <b>design</b> process is to develop an understanding of the relationships between the software that is being designed and its external environment. This is essential for deciding how to provide the required system functionality and how to structure the system to communicate with its environment. As I discussed in Chapter 5, understanding the <b>context</b> also lets you establish the boundaries of the system. Setting the system boundaries helps you decide what features are implemented in the system being designed and what features are in other associated systems. In this case, you need to decide how functionality is distributed between the control system for all of the weather stations and the embedded software in the weather station itself.</p>
<h3><u>Design</u> patterns</h3><p><b>Design</b> patterns were derived from ideas put forward by Christopher Alexander (Alexander 1979), who suggested that there were certain common patterns of building <b>design</b> that were inherently pleasing and effective. The pattern is a description of the problem and the essence of its solution, so that the solution may be reused in different settings. The pattern is not a detailed specification. Rather, you can think of it as a description of accumulated wisdom and experience, a well-tried solution to a common problem. A quote from the Hillside Group website (hillside.net/patterns/), which is dedicated to maintaining information about patterns, encapsulates their role in reuse: Patterns and Pattern Languages are ways to describe best practices, good designs, and capture experience in a way that it is possible for others to reuse this experience. Patterns have made a huge impact on object-oriented software <b>design</b>. As well as being tested solutions to common problems, they have become a vocabulary for talking about a <b>design</b>. You can therefore explain your <b>design</b> by describing the patterns that you have used. This is particularly true for the best known <b>design</b> patterns that were originally described by the 'Gang of Four' in their patterns book, published in 1995 (Gamma et al. 1995). Other important pattern descriptions are those published in a series of books by authors from Siemens, a large European technology company (Buschmann et al. 1996; Schmidt et al. 2000; Kircher and Jain 2004; Buschmann, Henney, and Schmidt 2007a, 2007b).</p>
<h3>System <u>context</u> and interactions</h3><p>The first stage in any software <b>design</b> process is to develop an understanding of the relationships between the software that is being designed and its external environment. This is essential for deciding how to provide the required system functionality and how to structure the system to communicate with its environment. As I discussed in Chapter 5, understanding the <b>context</b> also lets you establish the boundaries of the system. Setting the system boundaries helps you decide what features are implemented in the system being designed and what features are in other associated systems. In this case, you need to decide how functionality is distributed between the control system for all of the weather stations and the embedded software in the weather station itself.</p><h3><u>Design</u> patterns</h3><p><b>Design</b> patterns were derived from ideas put forward by Christopher Alexander (Alexander 1979), who suggested that there were certain common patterns of building <b>design</b> that were inherently pleasing and effective. The pattern is a description of the problem and the essence of its solution, so that the solution may be reused in different settings. The pattern is not a detailed specification. Rather, you can think of it as a description of accumulated wisdom and experience, a well-tried solution to a common problem. A quote from the Hillside Group website (hillside.net/patterns/), which is dedicated to maintaining information about patterns, encapsulates their role in reuse: Patterns and Pattern Languages are ways to describe best practices, good designs, and capture experience in a way that it is possible for others to reuse this experience. Patterns have made a huge impact on object-oriented software <b>design</b>. As well as being tested solutions to common problems, they have become a vocabulary for talking about a <b>design</b>. You can therefore explain your <b>design</b> by describing the patterns that you have used. This is particularly true for the best known <b>design</b> patterns that were originally described by the 'Gang of Four' in their patterns book, published in 1995 (Gamma et al. 1995). Other important pattern descriptions are those published in a series of books by authors from Siemens, a large European technology company (Buschmann et al. 1996; Schmidt et al. 2000; Kircher and Jain 2004; Buschmann, Henney, and Schmidt 2007a, 2007b).</p><h3><u>Design</u> models</h3><p><b>Design</b> or system models, as I discussed in Chapter 5, show the objects or object classes in a system. They also show the associations and relationships between these entities. These models are the bridge between the system requirements and the implementation of a system. They have to be abstract so that unnecessary detail doesn't hide the relationships between them and the system requirements. However, they also have to include enough detail for programmers to make implementation decisions. The level of detail that you need in a <b>design</b> model depends on the <b>design</b> process used. Where there are close links between requirements engineers, designers and programmers, then abstract models may be all that are required. Specific <b>design</b> decisions may be made as the system is implemented, with problems resolved through informal discussions. Similarly, if agile development is used, outline <b>design</b> models on a whiteboard may be all that is required.</p><h3>Interface specification</h3><p>An important part of any <b>design</b> process is the specification of the interfaces between the components in the <b>design</b>. You need to specify interfaces so that objects and subsystems can be designed in parallel. Once an interface has been specified, the developers of other objects may assume that interface will be implemented. Interface <b>design</b> is concerned with specifying the detail of the interface to an object or to a group of objects. This means defining the signatures and semantics of the services that are provided by the object or by a group of objects. Interfaces can be specified in the UML using the same notation as a class diagram. However, there is no attribute section, and the UML stereotype «interface» should be included in the name part. The semantics of the interface may be defined using the object constraint language (OCL). I discuss the use of the OCL in Chapter 16, where I explain how it can be used to describe the semantics of components. You should not include details of the data representation in an interface <b>design</b>, as attributes are not defined in an interface specification. However, you should include operations to access and update data. As the data representation is hidden, it can be easily changed without affecting the objects that use that data. This leads to a <b>design</b> that is inherently more maintainable. For example, an array representation of a stack may be changed to a list representation without affecting other objects that use the stack. By contrast, you should normally expose the attributes in an object model, as this is the clearest way of describing the essential characteristics of the objects.</p><h3>Object-oriented <u>design</u> using the UML</h3><p>An object-oriented system is made up of interacting objects that maintain their own local state and provide operations on that state. The representation of the state is private and cannot be accessed directly from outside the object. Object-oriented <b>design</b> processes involve designing object classes and the relationships between these classes. These classes define the objects in the system and their interactions. When the <b>design</b> is realized as an executing program, the objects are created dynamically from these class definitions. Objects include both data and operations to manipulate that data. They may therefore be understood and modified as stand-alone entities. Changing the implementation of an object or adding services should not affect other system objects. Because objects are associated with things, there is often a clear mapping between real-world entities (such as hardware components) and their controlling objects in the system. This improves the understandability, and hence the maintainability, of the <b>design</b>.</p><h3>Architectural <u>design</u></h3><p>Once the interactions between the software system and the system's environment have been defined, you use this information as a basis for designing the system architecture. Of course, you need to combine this knowledge with your general knowledge of the principles of architectural <b>design</b> and with more detailed domain knowledge. You identify the major components that make up the system and their interactions. You may then <b>design</b> the system organization using an architectural pattern such as a layered or client-server model. The high-level architectural <b>design</b> for the weather station software is shown in Figure 7.4. The weather station is composed of independent subsystems that communicate by broadcasting messages on a common infrastructure, shown as Communication link in Figure 7.4. Each subsystem listens for messages on that infrastructure and picks up the messages that are intended for them. This 'listener model' is a commonly used architectural style for distributed systems.</p><h3>Object class identification</h3><p>By this stage in the <b>design</b> process, you should have some ideas about the essential objects in the system that you are designing. As your understanding of the <b>design</b> develops, you refine these ideas about the system objects. The use case description helps to identify objects and operations in the system. From the description of the Report weather use case, it is obvious that you will need to implement objects representing the instruments that collect weather data and an object representing the summary of the weather data. You also usually need a high-level system object or objects that encapsulate the system interactions defined in the use cases. With these objects in mind, you can start to identify the general object classes in the system.</p><h3>Pattern name: <u>Observer</u></h3><p>Description: Separates the display of the state of an object from the object itself and allows alternative displays to be provided. When the object state changes, all displays are automatically notified and updated to reflect the change. Problem description: In many situations, you have to provide multiple displays of state information, such as a graphical display and a tabular display. Not all of these may be known when the information is specified. All alternative presentations should support interaction and, when the state is changed, all displays must be updated. This pattern may be used in situations where more than one display format for state information is required and where it is not necessary for the object that maintains the state information to know about the specific display formats used.</p>